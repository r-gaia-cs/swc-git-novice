<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Introdução ao Controle de Versão com Git</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap-responsive.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <div class="row-fluid">
        <div class="span10 offset1">
          <h1 class="title">Introdução ao Controle de Versão com Git</h1>
          <h2 class="subtitle">Uma Melhor Solução de Backup</h2>
<div id="objetivos" class="objectives">
<h2>Objetivos</h2>
<ul>
<li>Explicar os passos de inicialização e configuração necessários para cada máquina e aqueles necessários para cada repositório.</li>
<li>Passa pelo ciclo de modificação, adição e commit para um ou mais arquivos e explicar onde a informação é salva em cada estágio.</li>
<li>Identificar e utilizar o número de versão atribuído pelo Git.</li>
<li>Comparar o arquivo atual com versões antigas.</li>
<li>Restaurar versões antigas de arquivos.</li>
<li>Configurar Git para ignorar arquivos específicos, e explicar porque em</li>
<li>alguns casos é útil fazer isso.</li>
</ul>
</div>
<p>Nós vamos começar explorando como o controle de versão pode ser utilizado para manter o registro do que e de quando uma pessoa fez algo. Mesmo se você não estiver colaborando com outros, controle de versão é muito melhor que:</p>
<div>
<a href="http://www.phdcomics.com"><img src="fig/phd101212s.gif" alt="Piled Higher and Deeper by Jorge Cham, http://www.phdcomics.com" /></a>
<p>
&quot;Piled Higher and Deeper&quot; by Jorge Cham, http://www.phdcomics.com
</p>
</div>
<h3 id="configurando">Configurando</h3>
<p>Na primeira vez que utilizamos Git em uma máquina, precisamos configurar algumas coisas. A seguir encontra-se o que Drácula fez para configurar seu novo notebook:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> config --global user.name <span class="st">&quot;Vlad Dracula&quot;</span>
$ <span class="kw">git</span> config --global user.email <span class="st">&quot;vlad@tran.sylvan.ia&quot;</span>
$ <span class="kw">git</span> config --global color.ui <span class="st">&quot;auto&quot;</span>
$ <span class="kw">git</span> config --global core.editor <span class="st">&quot;nano&quot;</span></code></pre>
<p>(Por favor, utilize seu nome e endereço de email ao invés do de Drácula e por favor certifique-se que você escolheu um editor disponível no seu sistema, como o <code>notepad</code> se estiver utilizando Windows).</p>
<p>Os commandos do Git são escritos como <code>git verbo</code>, onde <code>verbo</code> é o que desejamos fazer. No caso anterior, estamos dizendo para o Git:</p>
<ul>
<li>nosso nome e endereço de email,</li>
<li>para colorir a saída,</li>
<li>qual o nosso editor de texto favorito, e</li>
<li>que queremos utilizar essas informações globalmente (i.e., para todo</li>
<li>projeto).</li>
</ul>
<p>Os quatro comandos anteriores só precisam ser executados uma vez: a opção (em inglês denominada de <em>flag</em>) <code>--global</code> diz para o Git utilizar as configurações para todo projeto na máquina atual.</p>
<div id="proxy" class="callout">
<h2>Proxy</h2>
<p>Em alguns casos você precisa utilizar um proxy para se conectar a internet. Se esse for o seu caso você precisa informar o Git sobre o proxy:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> config --global http.proxy proxy-url
$ <span class="kw">git</span> config --global https.proxy proxy-url</code></pre>
<p>To disable the proxy, use</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> config --global --unset http.proxy
$ <span class="kw">git</span> config --global --unset https.proxy</code></pre>
</div>
<h3 id="criando-um-repositório">Criando um repositório</h3>
<p>Uma vez que Git está configurado, podemos começar a utilizá-lo. Vamos criar um diretório para nosso trabalho:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> planetas
$ <span class="kw">cd</span> planetas</code></pre>
<p>e dizemos para fazer do diretório um <a href="../../gloss.html#repository">repositório</a>—um lugar onde Git irá armazenar as versões anteriores de nossos arquivos:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> init</code></pre>
<p>Se utilizarmos <code>ls</code> para mostrar o conteúdo do diretório irá parecer que nada foi feito:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span></code></pre>
<p>Mas se adicionarmos a opção <code>-a</code> para mostrar todos os arquivos, iremos ver que Git criou um diretório oculto denominado <code>.git</code>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span> -a</code></pre>
<pre class="output"><code>.   ..  .git</code></pre>
<p>Git armazena informações sobre o projeto nesse subdiretório especial. Se deletarmos ele iremos perder o histórico do projeto.</p>
<p>Podemos verificar que a configuração foi feita com sucesso requisitando o estado do nosso projeto para o Git:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use &quot;git add&quot; to track)</code></pre>
<h3 id="monitorando-alterações-nos-arquivos">Monitorando Alterações nos Arquivos</h3>
<p>Vamos criar um arquivo chamado <code>marte.txt</code> que contém algumas notas sobre a sustentabilidade de uma base no planeta vermelho. (Iremos utilizar um editor chamado <code>nano</code> para editar o arquivo mas você pode utilizar o editor de sua preferência. Em particular, ele não precisa ser o mesmo editor informado para o Git).</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">nano</span> marte.txt</code></pre>
<p>Escreva o texto abaixo no arquivo <code>marte.txt</code>:</p>
<pre><code>Frio e seco, mas tudo é da minha cor favorita.</code></pre>
<p><code>marte.txt</code> agora contem a seguinte linha:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span></code></pre>
<pre class="output"><code>marte.txt</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> marte.txt</code></pre>
<pre class="output"><code>Frio e seco, mas tudo é da minha cor favorita.</code></pre>
<p>Se verificarmos o estado do nosso projeto novamente, Git irá informar que ele encontrou um novo arquivo:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
#
# Initial commit
#
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#   marte.txt
nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
<p>A mensagem &quot;untracked files&quot; significa que existe um arquivo no diretório que Git não está monitorando. Iremos dizer para o Git que ele deve fazê-lo utilizando <code>git add</code>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> add marte.txt</code></pre>
<p>e então verificamos alteração na mensagem de estado:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)
#
#   new file:   marte.txt
#</code></pre>
<p>Git agora sabe que ele deve monitorar o arquivo <code>marte.txt</code> mas ele ainda não salvou nenhuma mudança para a posterioridade como um commit. Para fazer isso precisamos executar mais um comando:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> commit -m <span class="st">&quot;Começando a pensar em Marte&quot;</span></code></pre>
<pre class="output"><code>[master (root-commit) f22b25e] Começando a pensar em Marte
 1 file changed, 1 insertion(+)
 create mode 100644 marte.txt</code></pre>
<p>Quando executamos <code>git commit</code>, Git pega todas as mudanças que informamos precisar ser salvas quando utilizamos <code>git add</code> e armazena uma cópia permanente dentro do diretório especial <code>.git</code>. Essa cópia permanente é denominada <a href="../../gloss.html#revision">revisão</a> é brevemente identificada por <code>f22b25e</code>. (Sua revisão pode ter um identificador diferente.)</p>
<p>Utilizamos a opção <code>-m</code> (de &quot;mensagem&quot;) para salvar um comentário que irá nos ajudar a lembrar depois o que fizemos e porque. Se apenas executarmos <code>git commit</code> sem a opção <code>-m</code>, Git irá iniciar <code>nano</code> (ou o editor que tivermos configurado no início) para que possamos escrever um comentário longo.</p>
<p>Se executarmos <code>git status</code> agora:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
nothing to commit, working directory clean</code></pre>
<p>Git está dizendo que tudo está atualizado. Se desejarmos saber o que foi feito recentemente podemos pedir ao Git que mostre o histórico do projeto utilizando <code>git log</code>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> log</code></pre>
<pre class="output"><code>commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;
Date:   Thu Aug 22 09:51:46 2013 -0400

    Começando a pensar em Marte</code></pre>
<p><code>git log</code> lista todas as revisões salvas em um repositório na ordem cronológica reversa. Essa lista inclui, para cada revisão, o identificador completo da revisão (que inicia com os mesmos caracteres que o identificador curto impresso pelo comando <code>git commit</code> anteriormente), o autor da revisão, quando ela foi criada e o comentário dado à revisão quando ela foi criada.</p>
<div id="onde-estão-minhas-mudanças" class="callout">
<h2>Onde estão minhas mudanças?</h2>
<p>Se executarmos <code>ls</code> agora continuamos a encontrar apenas um arquivo chamado <code>marte.txt</code>. Isso deve-se ao fato do Git salvar as informações com histórico dos arquivos no diretório especial denominado <code>.git</code> mencionado anteriormente tal que nosso sitema de arquivos não fique cheio (e nós acidentalmente editemos ou removemos uma versão anterior.</p>
</div>
<h3 id="alterando-arquivos">Alterando arquivos</h3>
<p>Agora suponha adicionou algumas informações ao arquivo. (Novamente, editaremos o arquivo utilizando o <code>nano</code> e utilizaremos o commando <code>cat</code> para mostrar o conteúdo do arquivo; você pode utilizar outro editor e não precisa do comando <code>cat</code>.)</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">nano</span> marte.txt
$ <span class="kw">cat</span> marte.txt</code></pre>
<pre class="output"><code>Frio e seco, mas tudo é da minha cor favorita.
Duas luas pode ser um problema para o Lobisomem.</code></pre>
<p>Quando executamos o comando <code>git status</code>, ele irá informar que um arquivo sendo monitorado foi alterado:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#   modified:   marte.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<p>A última linha, &quot;no changes added to commit&quot;, é importante e nos avisa que nenhuma das mudanças feitas será salvo na próxima revisão. Embora tenhamos alterado o arquivo não informamos ao Git que queremos salvar essas mudanças (que iremos fazer utilizando <code>git add</code>). Para verificar as alterações nos arquivos utilizamos <code>git diff</code>, que irá mostrar a diferença entre o estado atual dos arquivo e a última revisão salva:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> diff</code></pre>
<pre class="output"><code>diff --git a/marte.txt b/mars.txt
index df0654a..315bf3a 100644
--- a/marte.txt
+++ b/marte.txt
@@ -1 +1,2 @@
 Frio e seco, mas tudo é da minha cor favorita.
+Duas luas pode ser um problema para o Lobisomem.</code></pre>
<p>A saída parecer criptografada porque na verdade é uma série de comandos dizendo para programas como editores de texto e <code>patch</code> como reconstruir um arquivo partindo do outro. Podemos quebrar essa saída em algumas partes:</p>
<ol style="list-style-type: decimal">
<li>A primeira linha informa que Git utilizou o comando <code>diff</code> para comparar a versão antiga com a nova.</li>
<li>A segunda linha informa exatamente quais <a href="../../gloss.html#revision">revisões</a> Git está comparando: <code>df0654a</code> e <code>315bf3a</code> são identificadores únicos gerados pelo computador para essas duas revisões.</li>
<li>As linhas restantes mostram o que realmente mudou e as linhas correspondentes. Em particular, o sinal <code>+</code> na primeira coluna indica onde adicionamos novas linhas.</li>
</ol>
<p>Vamos salvar nossas mudanças:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> commit -m <span class="st">&quot;Preocupações decorrentes das luas de Marte&quot;</span></code></pre>
<pre class="output"><code># On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#   modified:   marte.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<p>Hoops: Git não salvou uma nova revisão porque esquecemos de utilizar o comando <code>git add</code> primeiro. Vamos corrigir isso:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> add marte.txt
$ <span class="kw">git</span> commit -m <span class="st">&quot;Preocupações decorrentes das luas de Marte&quot;</span></code></pre>
<pre class="output"><code>[master 34961b1] Preocupações decorrentes das luas de Marte
 1 file changed, 1 insertion(+)</code></pre>
<p>Git insiste que adicionemos os arquivos ao grupo a ser salvo antes de realmente criarmos uma nova revisão porque podemos não querer incluir todas as mudanças de uma vez. Por exemplo, suponha que estejamos adicionando algumas citações ao trabalho de nosso orientador na nossa tese. Pode ser que desejamos ter uma versão em que adicionamos as citações e as referências bibliográficas mas <strong>não</strong> desejamos incluir as mudanças na conclusão uma vez que ainda não terminamos esta.</p>
<p>Para que isso seja possível, Git possui uma área temporária especial (em inglês denominada <em>staging area</em>) onde ele mantem o registro das alterações que foram adicionadas ao <a href="../../gloss.html#change-set">conjunto</a> a ser utilizado para o próximo commit (que ainda não foi feito). <code>git add</code> coloca as modificações nessa área e <code>git commit</code> move a informação dessa área para o armazenamento de longo termo na forma de um commit.</p>
<p><img src="fig/git-staging-area.svg" alt="The Git Staging Area" /></p>
<p>Vamos verificar como nossas mudanças são transmitidas do nosso editor para a área temporária e posteriormente para o armazenamento de longo termo. Primeiro, precisamos adicionar uma nova linha ao arquivo:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">nano</span> marte.txt
$ <span class="kw">cat</span> marte.txt</code></pre>
<pre class="output"><code>Frio e seco, mas tudo é da minha cor favorita.
Duas luas pode ser um problema para o Lobisomem.
Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> diff</code></pre>
<pre class="output"><code>diff --git a/marte.txt b/mars.txt
index 315bf3a..b36abfd 100644
--- a/marte.txt
+++ b/marte.txt
@@ -1,2 +1,3 @@
 Frio e seco, mas tudo é da minha cor favorita.
 Duas luas pode ser um problema para o Lobisomem.
+Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<p>Até agora, tudo bem: adicionamos uma nova linha no final do arquivo (identificada com o sinal <code>+</code> na primeira coluna). Agora vamos colocar essa mudança na área temporária e verificar o que <code>git diff</code> informa:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> add marte.txt
$ <span class="kw">git</span> diff</code></pre>
<p>Não existe saída pois até onde o Git consegue informar não existe diferença entre o que foi pedido para salvar permanentemente e o arquivos no repositório. Entretanto, se pedirmos:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> diff --staged</code></pre>
<pre class="output"><code>diff --git a/marte.txt b/mars.txt
index 315bf3a..b36abfd 100644
--- a/marte.txt
+++ b/marte.txt
@@ -1,2 +1,3 @@
 Frio e seco, mas tudo é da minha cor favorita.
 Duas luas pode ser um problema para o Lobisomem.
+Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<p>será mostrado a diferença entre o último commit e as mudanças na área temporária. Vamos salvar nossa mudança:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> commit -m <span class="st">&quot;Pensamentos sobre o clima&quot;</span></code></pre>
<pre class="output"><code>[master 005937f] Pensamentos sobre o clima
 1 file changed, 1 insertion(+)</code></pre>
<p>e verificar o estado do repositório:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
nothing to commit, working directory clean</code></pre>
<p>e também no histórico do que foi feito até agora:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> log</code></pre>
<pre class="output"><code>commit 005937fbe2a98fb83f0ade869025dc2636b4dad5
Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;
Date:   Thu Aug 22 10:14:07 2013 -0400

    Pensamentos sobre o clima

commit 34961b159c27df3b475cfe4415d94a6d1fcd064d
Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;
Date:   Thu Aug 22 10:07:21 2013 -0400

    Preocupações decorrentes das luas de Marte

commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;
Date:   Thu Aug 22 09:51:46 2013 -0400

    Começando a pensar em Marte</code></pre>
<h3 id="explorando-o-histórico">Explorando o histórico</h3>
<p>Se desejarmos ver o que alteramos, podemos utilizar <code>git diff</code> novamente, mas referindo-se a versões antigas utilizando a notação <code>HEAD~1</code>, <code>HEAD~2</code> e assim por diante:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> diff HEAD~1 marte.txt</code></pre>
<pre class="output"><code>diff --git a/marte.txt b/mars.txt
index 315bf3a..b36abfd 100644
--- a/marte.txt
+++ b/marte.txt
@@ -1,2 +1,3 @@
 Frio e seco, mas tudo é da minha cor favorita.
 Duas luas pode ser um problema para o Lobisomem.
+Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> diff HEAD~2 marte.txt</code></pre>
<pre class="output"><code>diff --git a/marte.txt b/mars.txt
index df0654a..b36abfd 100644
--- a/marte.txt
+++ b/marte.txt
@@ -1 +1,3 @@
 Frio e seco, mas tudo é da minha cor favorita.
+Duas luas pode ser um problema para o Lobisomem.
+Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<p>Dessa forma, criamos uma sequência de revisões. A revisão mais recente nessa sequência é referenciada por <code>HEAD</code> e podemos referenciar revisões anteriores utilizando a notação com <code>~</code>, tal que <code>HEAD~1</code> (pronuncia-se &quot;<em>head minus one</em>&quot;) significa a revisão anterior, enquanto <code>HEAD~123</code> retorna 123 revisões do ponto em que estamos agora.</p>
<p>Podemos também referenciar revisões anteriores utilizando a longa string de dígitos e letras impressas por <code>git log</code>. Essa longa string é única para as revisões e &quot;única&quot; realmente significa única: todo conjunto de mudanças em um conjunto de arquivos em cada máquina possui um identificador único de 40 caracteres. O nosso primeiro commit possui como identificado f22b25e3233b4645dabd0d81e651fe074bd8e73b. Então vamos tentar:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> diff f22b25e3233b4645dabd0d81e651fe074bd8e73b marte.txt</code></pre>
<pre class="output"><code>diff --git a/marte.txt b/mars.txt
index df0654a..b36abfd 100644
--- a/marte.txt
+++ b/marte.txt
@@ -1 +1,3 @@
 Frio e seco, mas tudo é da minha cor favorita.
+Duas luas pode ser um problema para o Lobisomem.
+Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<p>A resposta do Git está correta mas digitar 40 caracteres aleatórios é inconveniente e por isso Git permite você digitar apenas os primeiros caracteres:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> diff f22b25e marte.txt</code></pre>
<pre class="output"><code>diff --git a/marte.txt b/mars.txt
index df0654a..b36abfd 100644
--- a/marte.txt
+++ b/marte.txt
@@ -1 +1,3 @@
 Frio e seco, mas tudo é da minha cor favorita.
+Duas luas pode ser um problema para o Lobisomem.
+Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<h3 id="recuperando-versões-anteriores">Recuperando versões anteriores</h3>
<p>Até agora aprendemos como salvar alterações nos arquivos e verificar as alterações realizadas. Como podemos recuperar um arquivo de uma versão antiga? Vamos supor que acidentalmente sobre escrevemos um de nossos arquivos.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">nano</span> marte.txt
$ <span class="kw">cat</span> marte.txt</code></pre>
<pre class="output"><code>Teremos que produzir oxigênio para nosso consumo.</code></pre>
<p><code>git status</code> irá informar que os arquivo foi alterado e que as alterações não foram salvas na área temporária:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#   modified:   marte.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<p>Podemos desfazer as mudanças utilizando o comando <code>git checkout</code>: We can put things back the way they were by using <code>git checkout</code>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> checkout HEAD marte.txt
$ <span class="kw">cat</span> marte.txt</code></pre>
<pre class="output"><code>Frio e seco, mas tudo é da minha cor favorita.
Duas luas pode ser um problema para o Lobisomem.
Mas a Múmia irá apreciar a falta de humidade.</code></pre>
<p>Como você pode adivinhar pelo verbo utilizado, <code>git checkout</code> <em>checks out</em> (i.e., restaura) uma versão anterior do arquivo. Nesse caso, estamos dizendo para o Git que queremos recuperar a versão do arquivo presente em <code>HEAD</code>, que corresponde a última versão salva. Se você você resolver resolver voltar para uma versão mais antiga você deve utilizar o identificado da respectiva versão:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> checkout f22b25e marte.txt</code></pre>
<p>É importante lembrar que devemos utilizar o identificador da revisão <em>anterior</em> ao estado que desejamos desfazer. Um erro comum é utilizar o identificador da revisão na qual as alterações indesejadas foram feitas. No exemplo abaixo, queremos recuperar o estado anterior ao commit mais recente (<code>HEAD~1</code>), cuja identificação é <code>f22b25e</code>:</p>
<p><img src="fig/git-checkout.svg" alt="Git Checkout" /></p>
<p>O diagrama a seguir ilustra como o histórico de um arquivo deve ser (indo para antes de <code>HEAD</code>, a versão mais recente salva):</p>
<p><img src="fig/git-when-revisions-updated.svg" alt="When Git Updates Revision Numbers" /></p>
<div id="simplificando-o-caso-comum" class="callout">
<h2>Simplificando o Caso Comum</h2>
<p>Se você tiver lido cuidadosamente a saída do comando <code>git status</code> você terá notado que ele encontra a seguinte dica:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(use</span> <span class="st">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes in working directory<span class="kw">)</span></code></pre>
<p>Como ela diz, <code>git checkout</code> irá restaurar os arquivos para o estado salvo em <code>HEAD</code>. O traço duplo, <code>--</code>, é necessário para separar o nome do arquivo a ser recuperado do comando propriamente dito: sem o traço duplo, Git tentará utilizar o nome do arquivo como o identificador da revisão.</p>
</div>
<p>O fato de que os arquivos pode ser recuperados um por um tende a mudar a forma como as pessoas organizam seu trabalho. Se todo o trabalho consiste de um grande documento, será difícil (mas não impossível) de desfazer alguma mudança sem também desfazer outras, por exemplo desfazer as alterações na introdução sem também desfazer as alterações feitas na conclusão. Se a introdução e conclusão estiverem salvas em arquivos separados será muito mais fácil desfazer apenas as alterações em um dos arquivos.</p>
<h3 id="ignorando-coisas">Ignorando Coisas</h3>
<p>Se tivermos arquivos que não desejamos serem monitorados pelo Git, por exemplo arquivos de backup criados pelo nosso editor ou arquivos intermediários criados durante a análise de dados. Vamos criar um exemplo bobo:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> resultados
$ <span class="kw">touch</span> a.dat b.dat c.dat resultados/a.out resultados/b.out</code></pre>
<p>e verificar o que o Git diz:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#   a.dat
#   b.dat
#   c.dat
#   resultados/
nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
<p>Colocando esses arquivos sob controle de versão é um desperdício de memória em disco. Algo pior é que ter eles listados toda vez pode reduzir nossa atenção para as mudanças que realmente importam. Vamos então dizer para o Git ignorar alguns arquivos.</p>
<p>Fazemos isso criando um arquivo denominado <code>.gitignore</code> no diretório raiz do nosso projeto.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">nano</span> .gitignore
$ <span class="kw">cat</span> .gitignore</code></pre>
<pre class="output"><code>*.dat
resultados/</code></pre>
<p>A primeira expressão no arquivo <code>.gitignore</code> diz para o Git ignorar todos os arquivos que terminam com <code>.dat</code> e a segunda expressão para ele ignorar todos os arquivos dentro do diretório <code>resultados</code>. (Se algum desses arquivos já está sendo monitorado pelo Git ele continuará sendo-o).</p>
<p>Uma vez que criamos esse arquivo, a saída do comando <code>git status</code> é muito mais limpa.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#   .gitignore
nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
<p>A única alteração que Git nota é a criação do arquivo <code>.gitignore</code>. Inicialmente você pode pensar que você não quer monitorar esse arquivo mas todas as pessoas que fizerem uso do repositório provavelmente irão querer ignorar os mesmos arquivos que ignoramos. Por esse motivo, vamos adicionar o arquivo <code>.gitignore</code> ao nosso controle de versão:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> add .gitignore
$ <span class="kw">git</span> commit -m <span class="st">&quot;Adicionado gitignore&quot;</span>
$ <span class="kw">git</span> status</code></pre>
<pre class="output"><code># On branch master
nothing to commit, working directory clean</code></pre>
<p>Como um bônus, utilizar <code>.gitignore</code> irá ajudar nos a evitar de acidentadamente adicionar arquivos indesejados.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> add a.dat</code></pre>
<pre class="output"><code>The following paths are ignored by one of your .gitignore files:
a.dat
Use -f if you really want to add them.
fatal: no files added</code></pre>
<p>Se realmente desejarmos desobedecer nossas configurações presentes no <code>.gitignore</code> precisamos informar isso ao Git utilizando <code>git add -f</code>. Também podemos verificar o status dos arquivos ignorados utilizando:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> status --ignored</code></pre>
<pre class="output"><code># On branch master
# Ignored files:
#  (use &quot;git add -f &lt;file&gt;...&quot; to include in what will be committed)
#
#        a.dat
#        b.dat
#        c.dat
#        resultados/

nothing to commit, working directory clean</code></pre>
<blockquote>
<h2 id="repositório-bio">Repositório <code class="challenge">bio</code></h2>
<p>Crie um novo repositório Git no seu computador chamado <code>bio</code>. Escreva uma versão curta da sua bibliografia com três linhas no arquivo <code>me.txt</code>, salva suas mudanças. Depois, modifique uma das linhas e adicione uma quarta linha, mostre a alteração feita e desfaça-a.</p>
</blockquote>
<div id="onde-posso-criar-meu-repositório" class="challenge">
<h2>Onde posso criar meu repositório?</h2>
<p>A seguinte sequencia de comandos cira um repositório Git dentro de outro:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cd</span>           <span class="co"># retorna para sua pasta de usuário</span>
<span class="kw">mkdir</span> alpha  <span class="co"># cria um novo repositório</span>
<span class="kw">cd</span> alpha     <span class="co"># muda o diretório atual para o diretório recém criado</span>
<span class="kw">git</span> init     <span class="co"># transforma o diretório recém criado em um repositório Git</span>
<span class="kw">mkdir</span> beta   <span class="co"># cria um subdiretório</span>
<span class="kw">cd</span> beta      <span class="co"># muda o diretório atual para o subdiretório recém criado</span>
<span class="kw">git</span> init     <span class="co"># transforma o subdiretório em um repositório Git</span></code></pre>
<p>Por que utilizar um repositório Git dentro de outro é uma péssima idéia?</p>
</div>
        </div>
      </div>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/git-novice">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="http://software-carpentry.org/v5/js/bootstrap/bootstrap.min.js"></script>
  </body>
</html>
